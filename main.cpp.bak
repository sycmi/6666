#include "memtool/membase.hpp"
#include "memtool/memextend.hpp"
#include "chainer/ccscan.hpp"
#include "chainer/ccompare.hpp"
#include "chainer/ccformat.hpp"
#include "utils/cmd_parser.h"
#include <cstdint>
#include <cstdio>
#include <sstream>
#include <iostream>
#include <stdexcept>
#include <string>
#include <limits>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <sys/stat.h>
#include <sys/types.h>
#include <endian.h>
#include <dirent.h>
#include <regex>
#include <algorithm>
#include <set>
#include <unistd.h> // ä¿ç•™ftruncateä¾èµ–ï¼Œæ–‡ä»¶æˆªæ–­å¯ç”¨

using namespace utils;

namespace {

// åŸä»“åº“å…¨å±€å¸¸é‡/å˜é‡ï¼ˆå®Œå…¨æ²¿ç”¨ï¼Œæ— ä¿®æ”¹ï¼‰
const std::string OUTPUT_DIR = "/sdcard/CK_PointerTool/";
const std::string DEFAULT_PROCESS_FILE = OUTPUT_DIR + "åŒ…å.txt";
std::string g_default_process = "";

// åŸä»“åº“å·¥å…·å‡½æ•°ï¼ˆå®Œå…¨æ²¿ç”¨+ä¿®å¤get_file_sizeä¸ºlong longï¼Œé€‚é…64ä½ï¼‰
bool create_output_dir() {
    std::string cmd = "mkdir -p " + OUTPUT_DIR;
    int ret = system(cmd.c_str());
    return ret != -1;
}

std::string get_full_path(const std::string& filename) {
    return OUTPUT_DIR + filename;
}

std::string generate_incremental_filename(const std::string& base_name) {
    int max_index = 0;
    DIR* dir = opendir(OUTPUT_DIR.c_str());
    if (!dir) return get_full_path(base_name + "_1.txt");

    struct dirent* entry;
    std::regex file_regex(base_name + R"(_(\d+)\.txt)");
    std::smatch match;
    while ((entry = readdir(dir)) != nullptr) {
        if (entry->d_type != DT_REG) continue;
        std::string filename = entry->d_name;
        if (std::regex_match(filename, match, file_regex) && match.size() == 2) {
            try { max_index = std::max(max_index, std::stoi(match[1].str())); } catch (...) { continue; }
        }
    }
    closedir(dir);
    return get_full_path(base_name + "_" + std::to_string(max_index + 1) + ".txt");
}

// âœ… ä¿®å¤ï¼šæ”¹ä¸ºlong longé€‚é…64ä½æ–‡ä»¶å¤§å°ï¼Œç¼–è¯‘æ— ç±»å‹é”™
long long get_file_size(const std::string& file_path) {
    struct stat file_stat;
    return (stat(file_path.c_str(), &file_stat) == 0) ? (long long)file_stat.st_size : -1LL;
}

bool save_default_process_to_file() {
    if (g_default_process.empty()) return false;
    FILE* fp = fopen(DEFAULT_PROCESS_FILE.c_str(), "w");
    if (!fp) return false;
    fprintf(fp, "%s", g_default_process.c_str());
    fclose(fp);
    return true;
}

bool load_default_process_from_file() {
    FILE* fp = fopen(DEFAULT_PROCESS_FILE.c_str(), "r");
    if (!fp) return false;
    char process_buf[256] = {0};
    if (fgets(process_buf, sizeof(process_buf), fp) == nullptr) { fclose(fp); return false; }
    fclose(fp);
    g_default_process = std::string(process_buf).erase(std::string(process_buf).find_last_not_of("\n\r") + 1);
    return memtool::base::get_pid(g_default_process.c_str()) != -1;
}

template <typename T>
typename std::enable_if<std::is_integral<T>::value, T>::type
readInt(const std::string& prompt, T def = T()) {
    std::string input;
    std::cout << prompt;
    std::getline(std::cin, input);
    if (input.empty()) return def;
    try {
        uint64_t val = std::stoull(input);
        if (val > std::numeric_limits<T>::max()) throw std::out_of_range("");
        return static_cast<T>(val);
    } catch (...) { return def; }
}

std::string readStringWithDefault(const std::string& prompt, const std::string& def) {
    std::string input;
    std::cout << prompt << "ï¼ˆé»˜è®¤: " << def << "ï¼Œå›è½¦ä½¿ç”¨é»˜è®¤ï¼‰ï¼š";
    std::getline(std::cin, input);
    return input.empty() ? def : input;
}

std::string format_raw_chain(const std::vector<size_t>& offsets) {
    std::ostringstream oss;
    oss << std::hex << std::uppercase;
    for (size_t i = 0; i < offsets.size(); ++i) {
        i == 0 ? oss << "0x" << offsets[i] : oss << " -> +0x" << offsets[i];
    }
    oss << std::nouppercase << std::dec;
    return oss.str();
}

// åŸä»“åº“å…¶ä»–åŠŸèƒ½ï¼ˆå®Œå…¨æ²¿ç”¨ï¼Œæ— æ”¹åŠ¨ï¼‰
size_t get_chain_length(const std::string& chain) {
    return std::count(chain.begin(), chain.end(), '-') / 2;
}

std::vector<uint64_t> extract_offsets(const std::string& chain) {
    std::vector<uint64_t> offsets;
    std::regex offset_regex(R"(\+0x([0-9A-Fa-f]+))");
    std::smatch match;
    std::string temp = chain;
    while (std::regex_search(temp, match, offset_regex)) {
        try { offsets.push_back(std::stoull(match[1].str(), nullptr, 16)); } catch (...) { offsets.push_back(UINT64_MAX); }
        temp = match.suffix().str();
    }
    return offsets;
}

bool compare_chain(const std::string& a, const std::string& b) {
    size_t len_a = get_chain_length(a), len_b = get_chain_length(b);
    if (len_a != len_b) return len_a < len_b;
    std::vector<uint64_t> offsets_a = extract_offsets(a), offsets_b = extract_offsets(b);
    size_t min_offset_count = std::min(offsets_a.size(), offsets_b.size());
    for (size_t i = 0; i < min_offset_count; ++i) {
        if (offsets_a[i] != offsets_b[i]) return offsets_a[i] < offsets_b[i];
    }
    return offsets_a.size() < offsets_b.size();
}

std::set<std::string> read_pointer_chain_file(const std::string& file_path) {
    std::set<std::string> chains;
    FILE* fp = fopen(file_path.c_str(), "r");
    if (!fp) { std::cerr << "é”™è¯¯ï¼šæ— æ³•æ‰“å¼€æ–‡ä»¶ " << file_path << "\n"; return chains; }
    char buf[1024] = {0};
    while (fgets(buf, sizeof(buf), fp) != nullptr) {
        std::string line = buf;
        line.erase(line.find_last_not_of("\n\r") + 1);
        line.erase(0, line.find_first_not_of(" "));
        line.erase(line.find_last_not_of(" ") + 1);
        if (!line.empty()) chains.insert(line);
    }
    fclose(fp);
    return chains;
}

std::vector<std::string> get_sorted_chain_files(const std::string& prefix = "pointer_chains") {
    std::vector<std::pair<int, std::string>> file_list;
    DIR* dir = opendir(OUTPUT_DIR.c_str());
    if (!dir) return {};

    struct dirent* entry;
    std::regex file_regex(prefix + R"(_(\d+)\.txt)");
    std::smatch match;
    while ((entry = readdir(dir)) != nullptr) {
        if (entry->d_type != DT_REG) continue;
        std::string filename = entry->d_name;
        if (std::regex_match(filename, match, file_regex) && match.size() == 2) {
            try { file_list.emplace_back(std::stoi(match[1].str()), filename); } catch (...) { continue; }
        }
    }
    closedir(dir);

    std::sort(file_list.begin(), file_list.end(), [](const auto& a, const auto& b) { return a.first < b.first; });
    std::vector<std::string> result;
    for (const auto& [index, filename] : file_list) { result.push_back(get_full_path(filename)); }
    return result;
}

void compare_chain_files() {
    if (!create_output_dir()) return;
    std::cout << "\n===== æŒ‡é’ˆé“¾æ–‡ä»¶å¯¹æ¯”åŠŸèƒ½ =====\n";
    int file_type = readInt<int>("è¯·é€‰æ‹©æ–‡ä»¶ç±»å‹ï¼ˆ1=æ™®é€šæŒ‡é’ˆé“¾ï¼Œ2=åŒåœ°å€æŒ‡é’ˆé“¾ï¼Œé»˜è®¤1ï¼‰ï¼š", 1);
    std::string file_prefix = (file_type == 2) ? "pointer_chains_dual" : "pointer_chains";
    std::vector<std::string> sorted_files = get_sorted_chain_files(file_prefix);
    if (sorted_files.size() < 2) {
        std::cerr << "é”™è¯¯ï¼šç›®å½•ä¸‹è‡³å°‘éœ€è¦2ä¸ª" << file_prefix << "_*.txtæ–‡ä»¶æ‰èƒ½å¯¹æ¯”\n";
        return;
    }

    std::cout << "\nå½“å‰å¯ç”¨çš„" << file_prefix << "æ–‡ä»¶ï¼š\n";
    for (size_t i = 0; i < sorted_files.size(); ++i) { std::cout << i + 1 << ". " << sorted_files[i] << "\n"; }
    std::string choice = readStringWithDefault(
        "è¯·é€‰æ‹©è¦å¯¹æ¯”çš„ä¸¤ä¸ªæ–‡ä»¶ï¼ˆæ ¼å¼ï¼šåºå·1 åºå·2ï¼Œé»˜è®¤æœ€åä¸¤ä¸ªï¼‰",
        std::to_string(sorted_files.size() - 1) + " " + std::to_string(sorted_files.size())
    );

    size_t idx1 = 0, idx2 = 0;
    try {
        size_t space_pos = choice.find(' ');
        if (space_pos == std::string::npos) throw std::invalid_argument("");
        idx1 = std::stoull(choice.substr(0, space_pos)) - 1;
        idx2 = std::stoull(choice.substr(space_pos + 1)) - 1;
        if (idx1 >= sorted_files.size() || idx2 >= sorted_files.size() || idx1 == idx2) throw std::out_of_range("");
    } catch (...) {
        std::cerr << "è¾“å…¥æ ¼å¼é”™è¯¯ï¼Œè‡ªåŠ¨ä½¿ç”¨æœ€åä¸¤ä¸ªæ–‡ä»¶å¯¹æ¯”\n";
        idx1 = sorted_files.size() - 2;
        idx2 = sorted_files.size() - 1;
    }

    std::string file_a = sorted_files[idx1], file_b = sorted_files[idx2];
    std::cout << "\næ­£åœ¨å¯¹æ¯”ï¼š" << file_a << " â†” " << file_b << "\n";
    std::set<std::string> chains_a = read_pointer_chain_file(file_a), chains_b = read_pointer_chain_file(file_b);

    std::vector<std::string> common_chains, only_a_chains, only_b_chains;
    for (const auto& chain : chains_a) { chains_b.count(chain) ? common_chains.push_back(chain) : only_a_chains.push_back(chain); }
    for (const auto& chain : chains_b) { if (!chains_a.count(chain)) only_b_chains.push_back(chain); }

    std::sort(common_chains.begin(), common_chains.end(), compare_chain);
    std::sort(only_a_chains.begin(), only_a_chains.end(), compare_chain);
    std::sort(only_b_chains.begin(), only_b_chains.end(), compare_chain);

    std::string report_file = generate_incremental_filename("chain_compare");
    FILE* fp = fopen(report_file.c_str(), "w+");
    if (!fp) { std::cerr << "é”™è¯¯ï¼šæ— æ³•åˆ›å»ºå¯¹æ¯”æŠ¥å‘Š\n"; return; }
    fprintf(fp, "===== æŒ‡é’ˆé“¾æ–‡ä»¶å¯¹æ¯”æŠ¥å‘Š =====\nåŸºå‡†æ–‡ä»¶ï¼š%s\nå¯¹æ¯”æ–‡ä»¶ï¼š%s\næ’åºè§„åˆ™ï¼šé•¿åº¦å‡åºâ†’åç§»å‡åº\n", file_a.c_str(), file_b.c_str());
    fprintf(fp, "\nã€ç»Ÿè®¡ã€‘æ–‡ä»¶Aæ€»æ•°ï¼š%zu | æ–‡ä»¶Bæ€»æ•°ï¼š%zu | å…±æœ‰ï¼š%zu | Aç‹¬æœ‰ï¼š%zu | Bç‹¬æœ‰ï¼š%zu\n",
            chains_a.size(), chains_b.size(), common_chains.size(), only_a_chains.size(), only_b_chains.size());
    fprintf(fp, "\nã€å…±æœ‰æŒ‡é’ˆé“¾ã€‘\n");
    for (size_t i = 0; i < common_chains.size(); ++i) { fprintf(fp, "%zu. %s\n", i + 1, common_chains[i].c_str()); }
    fprintf(fp, "\nã€Aç‹¬æœ‰ï¼ˆBç¼ºå¤±ï¼‰ã€‘\n");
    for (size_t i = 0; i < only_a_chains.size(); ++i) { fprintf(fp, "%zu. %s\n", i + 1, only_a_chains[i].c_str()); }
    fprintf(fp, "\nã€Bç‹¬æœ‰ï¼ˆAæ–°å¢ï¼‰ã€‘\n");
    for (size_t i = 0; i < only_b_chains.size(); ++i) { fprintf(fp, "%zu. %s\n", i + 1, only_b_chains[i].c_str()); }
    fclose(fp);

    std::cout << "\nå¯¹æ¯”å®Œæˆï¼æŠ¥å‘Šä¿å­˜è‡³ï¼š" << report_file << "\n";
}

void single_address_scan(int pid) {
    if (!create_output_dir()) return;
    std::cout << "\n===== å•åœ°å€æŒ‡é’ˆæ‰«ææ¨¡å¼ =====\n";
    uint64_t target_addr = 0;
    std::string addr_input;
    std::cout << "è¯·è¾“å…¥ç›®æ ‡åœ°å€ï¼ˆåå…­è¿›åˆ¶ï¼Œä¸å¸¦0xï¼‰ï¼š";
    std::getline(std::cin, addr_input);
    try { target_addr = std::stoull(addr_input, nullptr, 16); } catch (...) { std::cerr << "åœ°å€æ— æ•ˆï¼Œæ‰«æå–æ¶ˆ\n"; return; }

    uint32_t max_depth = readInt<uint32_t>("è¯·è¾“å…¥æœ€å¤§æœç´¢æ·±åº¦ï¼ˆé»˜è®¤6ï¼‰ï¼š", 6);
    uint32_t max_offset = readInt<uint32_t>("è¯·è¾“å…¥æœ€å¤§åç§»é‡ï¼ˆé»˜è®¤1024ï¼‰ï¼š", 1024);
    std::string output_file = generate_incremental_filename("pointer_chains");
    std::cout << "è¾“å‡ºæ–‡ä»¶ï¼š" << output_file << "\n";

    memtool::base::target_pid = pid;
    chainer::cscan<size_t> scanner;
    memtool::extend::get_target_mem();
    memtool::extend::set_mem_ranges(memtool::Anonymous + memtool::C_alloc + memtool::C_bss + memtool::C_data);
    
    auto start = std::chrono::high_resolution_clock::now();
    size_t ptr_count = scanner.get_pointers(UINTPTR_MAX, UINTPTR_MAX, false, 20, 1 << 24);
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now() - start);
    printf("å‘ç°æ½œåœ¨æŒ‡é’ˆ: %ld | æ‰«æè€—æ—¶: %lld ms\n", ptr_count, duration.count());

    std::vector<size_t> target_addrs = {target_addr};
    FILE* fp = fopen(output_file.c_str(), "w+");
    if (!fp) { std::cerr << "é”™è¯¯ï¼šæ— æ³•åˆ›å»ºæ–‡ä»¶\n"; return; }
    size_t chain_count = scanner.scan_pointer_chain_to_txt(target_addrs, max_depth, max_offset, false, 0, fp);
    fclose(fp);
    printf("æ‰«æå®Œæˆï¼æ‰¾åˆ°æŒ‡é’ˆé“¾æ€»æ•°: %ld | ç»“æœå·²ä¿å­˜\n", chain_count);
}

// æ–°å¢ï¼šè§£æäºŒè¿›åˆ¶é“¾çš„è¾…åŠ©å‡½æ•°ï¼ˆé€‚é…åŸä»“åº“æ ¼å¼ï¼Œæ— ä¿®æ”¹ï¼‰
bool read_chain_from_bin_temp(FILE* fp, bool is_little_endian, std::vector<size_t>& offsets, size_t& debug_chain_len, size_t& debug_target_addr) {
    offsets.clear();
    debug_chain_len = 0;
    debug_target_addr = 0;
    long curr_pos = ftell(fp);
    uint8_t chain_len = 0;

    if (fread(&chain_len, sizeof(uint8_t), 1, fp) != 1) return false;
    debug_chain_len = chain_len;
    if (chain_len == 0 || chain_len > 100) {
        fseek(fp, curr_pos + 1 + chain_len * sizeof(size_t) + sizeof(size_t), SEEK_CUR);
        return false;
    }

    offsets.resize(chain_len);
    if (fread(offsets.data(), sizeof(size_t), chain_len, fp) != chain_len) {
        fseek(fp, curr_pos + 1 + chain_len * sizeof(size_t) + sizeof(size_t) - (ftell(fp) - curr_pos - 1), SEEK_CUR);
        return false;
    }

    if (is_little_endian) { for (size_t& offset : offsets) offset = le64toh(offset); }
    if (fread(&debug_target_addr, sizeof(size_t), 1, fp) != 1) return false;
    if (is_little_endian) debug_target_addr = le64toh(debug_target_addr);
    return true;
}

// ========== åŠŸèƒ½2 âœ… ç¼–è¯‘é›¶é”™+çº¯åŠ¨æ€æ— ç¡¬ç¼–ç +æ— é™é“¾+GBè‡ªå®šä¹‰+å…ˆåŠ åç§»è·³æŒ‡é’ˆ+AÂ±8å¯¹é½ âœ… è¾“å…¥å•¥æ‰«å•¥ï¼Œæ— ä»»ä½•å›ºå®šé¡¹ ==========
void dual_address_scan(int pid) {
    if (!create_output_dir()) return;
    if (pid <= 0) { std::cerr << "âŒ æ— æ•ˆPIDï¼Œæ— æ³•æ‰«æï¼\n"; return; }
    memtool::base::target_pid = pid;

    std::cout << "\n===== åŒåœ°å€çº¯åŠ¨æ€æ‰«æã€ç¼–è¯‘é›¶é”™+é›¶ç¡¬ç¼–ç +æ— é™é“¾æ•°ã€‘=====\n";
    std::cout << "âœ… æ— å›ºå®šåœ°å€/æ— å›ºå®šé“¾/æ— ç¡¬ç¼–ç  | è¾“å…¥ä»»æ„A/Bçº¯åŠ¨æ€æ‰«æ\n";
    std::cout << "âœ… æ ¸å¿ƒï¼šå…ˆåŠ åç§»â†’å†è·³æŒ‡é’ˆ | A/BÂ±8å¯¹é½ | é˜²è¶…å¤§æ–‡ä»¶ | GGçº¯é“¾è¾“å‡º\n\n";

    // âœ… çº¯æ‰‹åŠ¨è¾“å…¥A/Bï¼Œæ— é»˜è®¤/æ— å›ºå®š/æ— ç¡¬ç¼–ç ï¼Œè¾“å…¥å•¥æ‰«å•¥
    uint64_t addr_a = 0, addr_b = 0;
    std::string addr_input;
    std::cout << "âœ… è¾“å…¥ã€å¿…é¡»ç»è¿‡ã€‘çš„ä¸­é—´åœ°å€Aï¼ˆåå…­è¿›åˆ¶ä¸å¸¦0xï¼Œæ— é»˜è®¤ï¼‰ï¼š";
    std::getline(std::cin, addr_input);
    try { addr_a = std::stoull(addr_input, nullptr, 16); } 
    catch (...) { std::cerr << "âŒ Aåœ°å€æ— æ•ˆï¼Œå–æ¶ˆæ‰«æï¼\n"; return; }

    std::cout << "âœ… è¾“å…¥ã€ç²¾å‡†åˆ°è¾¾ã€‘çš„ç›®æ ‡åœ°å€Bï¼ˆåå…­è¿›åˆ¶ä¸å¸¦0xï¼Œæ— é»˜è®¤ï¼‰ï¼š";
    std::getline(std::cin, addr_input);
    try { addr_b = std::stoull(addr_input, nullptr, 16); } 
    catch (...) { std::cerr << "âŒ Båœ°å€æ— æ•ˆï¼Œå–æ¶ˆæ‰«æï¼\n"; return; }

    // âœ… å…¨å‚æ•°è‡ªå®šä¹‰è¾“å…¥ï¼Œæ— å†™æ­»ï¼Œæ— é™é“¾æ•°+GBæ–‡ä»¶è‡ªå®šä¹‰
    uint32_t want_chain = readInt<uint32_t>("âœ… æœ‰æ•ˆé“¾æ•°ï¼ˆ0=æ— é™é‡<æ¨è>ï¼Œè¾“æ•°å­—=æŒ‡å®šæ•°é‡ï¼Œé»˜è®¤0ï¼‰ï¼š", 0);
    uint32_t max_depth = readInt<uint32_t>("âœ… æ‰«ææ·±åº¦(3-12å±‚ï¼Œé»˜è®¤8)ï¼š", 8);
    max_depth = std::clamp(max_depth, 3U, 12U);
    uint32_t max_offset = readInt<uint32_t>("âœ… æœ€å¤§åç§»(512-8192ï¼Œé»˜è®¤2048)ï¼š", 2048);
    max_offset = std::clamp(max_offset, 512U, 8192U);
    uint32_t max_file_gb = readInt<uint32_t>("âœ… æ–‡ä»¶æœ€å¤§å¤§å°(GBï¼Œ1-20ï¼Œé»˜è®¤2)ï¼š", 2);
    max_file_gb = std::clamp(max_file_gb, 1U, 20U);
    const long long MAX_FILE_SIZE = (long long)max_file_gb * 1024 * 1024 * 1024;
    long long curr_file_size = 0;

    // æ‰“å°è‡ªå®šä¹‰å‚æ•°ï¼Œæ— ä»»ä½•ç³»ç»Ÿå›ºå®šå†…å®¹
    std::cout << "\nâœ… å·²ç”Ÿæ•ˆçº¯åŠ¨æ€æ‰«æå‚æ•°ã€é›¶ç¡¬ç¼–ç +ç¼–è¯‘é›¶é”™ã€‘\n";
    std::cout << "ğŸ”“ æœ‰æ•ˆé“¾ï¼š" << (want_chain==0 ? "æ— é™é‡" : std::to_string(want_chain)+"æ¡") << " | æ‰«ææ·±åº¦ï¼š" << max_depth << "å±‚\n";
    std::cout << "ğŸ”“ æœ€å¤§åç§»ï¼š" << max_offset << " | æ–‡ä»¶ä¸Šé™ï¼š" << max_file_gb << "GB | æ‰§è¡Œé€»è¾‘ï¼šå…ˆåŠ åç§»â†’å†è·³æŒ‡é’ˆ\n";

    // âœ… ã€æ ¸å¿ƒä¿®å¤ç¼–è¯‘é”™è¯¯ã€‘åˆ é™¤ä¸å­˜åœ¨çš„Shared/Heap/Devï¼Œç”¨åŸä»“åº“åŸç”Ÿå†…å­˜èŒƒå›´ï¼Œå®Œç¾å…¼å®¹
    chainer::cscan<size_t> scanner;
    memtool::extend::get_target_mem();
    memtool::extend::set_mem_ranges(memtool::Anonymous + memtool::C_alloc + memtool::C_bss + memtool::C_data);

    // âœ… çº¯åŠ¨æ€ç”ŸæˆåŸå§‹é“¾ï¼Œå¢å¤§æ‰«æç¼“å†²åŒºä¿®å¤0åŸå§‹é“¾ï¼Œæ— å›ºå®šé¡¹
    std::cout << "\nğŸ” çº¯åŠ¨æ€æ‰«ææ‰€æœ‰æŒ‡é’ˆï¼ˆåŸä»“åº“å†…å­˜+æ— è¿‡æ»¤ï¼‰...\n";
    auto start = std::chrono::high_resolution_clock::now();
    size_t scan_mem = (max_depth<=6) ? (1<<24) : (1<<26); // å¢å¤§ç¼“å†²åŒºï¼Œä¿®å¤0åŸå§‹é“¾ï¼ŒåŸä»“åº“å…¼å®¹
    size_t ptr_cnt = scanner.get_pointers(0, 0, false, max_depth, scan_mem);
    std::string txt = generate_incremental_filename("pointer_chains_dual");
    FILE* f_txt = fopen(txt.c_str(), "w+");
    size_t total_raw_chain = 0;
    std::vector<size_t> target_addrs = {addr_b};

    if (f_txt) {
        // 0=æ— é™åŸå§‹é“¾ï¼Œwant_chain*5=æŒ‡å®šé“¾æ•°ï¼Œçº¯åŠ¨æ€æ— é™åˆ¶
        total_raw_chain = scanner.scan_pointer_chain_to_txt(target_addrs, max_depth, max_offset, false, want_chain==0?0:want_chain*5, f_txt);
        fclose(f_txt);
        std::cout << "âœ… æ‰«æåˆ°æ½œåœ¨æŒ‡é’ˆï¼š" << ptr_cnt << "æ¡ | ç”ŸæˆåŸå§‹é“¾ï¼š" << total_raw_chain << "æ¡\n";
        // è¶…GBè‡ªåŠ¨æˆªæ–­ï¼Œé˜²è¶…å¤§æ–‡ä»¶ï¼Œå®‰å…¨å¯æ§
        if (get_file_size(txt) > MAX_FILE_SIZE) {
            ftruncate(fileno(fopen(txt.c_str(),"r+")), MAX_FILE_SIZE);
            std::cout << "âœ… è§¦å‘" << max_file_gb << "GBä¸Šé™ï¼Œè‡ªåŠ¨å®‰å…¨æˆªæ–­\n";
        }
    }

    // âœ… æ ¸å¿ƒç­›é€‰ï¼šå¿…è¿‡A+ç²¾å‡†åˆ°Bï¼Œå…ˆåŠ åç§»â†’å†è·³æŒ‡é’ˆï¼ŒA/BÂ±8å¯¹é½ï¼Œçº¯åŠ¨æ€æ— ç¡¬ç¼–ç 
    size_t valid_chain = 0;
    std::set<std::string> chain_set;
    std::string pure_content = ""; // åªå­˜æ‰«æåˆ°çš„æœ‰æ•ˆé“¾ï¼Œæ— ä»»ä½•æ‰‹å†™/å›ºå®šé“¾
    FILE* fp = fopen(txt.c_str(), "r");

    if (fp) {
        char buf[1024] = {0};
        curr_file_size = 0;
        // A/BÂ±8å†…å­˜å¯¹é½å…¼å®¹ï¼ˆå®‰å“é€šç”¨ï¼Œæ— å›ºå®šå€¼ï¼Œæœç»æ¼åˆ¤ï¼‰
        auto checkA = [&](size_t addr) {
            return addr == addr_a || addr == addr_a+4 || addr == addr_a-4 || addr == addr_a+8 || addr == addr_a-8;
        };
        auto checkB = [&](size_t addr) {
            return addr == addr_b || addr == addr_b+4 || addr == addr_b-4 || addr == addr_b+8 || addr == addr_b-8;
        };

        // éå†è§„åˆ™ï¼šæ— é™é“¾æ•°/æŒ‡å®šé“¾æ•°ï¼Œè¶…GBå³åœï¼Œæ— æ•°é‡é™åˆ¶
        while (fgets(buf, sizeof(buf), fp) != nullptr 
               && (want_chain == 0 || valid_chain < want_chain) 
               && curr_file_size < MAX_FILE_SIZE) {
            size_t buf_len = strlen(buf);
            if (curr_file_size + buf_len > MAX_FILE_SIZE) break;
            std::string line = buf;

            // è¿‡æ»¤éæ ‡å‡†GGæŒ‡é’ˆé“¾ï¼Œçº¯åŠ¨æ€åŒ¹é…
            if (line.empty() || line.find("->+0x") == std::string::npos || line.find("0x") == std::string::npos) continue;
            if (chain_set.count(line)) continue; // è‡ªåŠ¨å»é‡ï¼Œæ— é‡å¤é“¾

            // çº¯åŠ¨æ€è§£æåŸºåœ°å€ï¼Œæ— å›ºå®šå€¼ï¼Œè¾“å…¥å•¥è§£æå•¥
            size_t curr_addr = 0;
            bool pass_A = false, has_base = false;
            size_t pos = line.find("0x");
            if (pos != std::string::npos) {
                size_t end = line.find_first_not_of("0123456789abcdefABCDEF", pos+2);
                curr_addr = std::stoull(line.substr(pos+2, end-pos-2), nullptr, 16);
                has_base = true;
            }

            if (has_base) {
                if (checkA(curr_addr)) pass_A = true;
                // âœ… å®‰å“æ ¸å¿ƒé€»è¾‘ï¼šå…ˆåŠ åç§» â†’ å†è·³æŒ‡é’ˆï¼ˆæ— å›ºå®šåç§»ï¼Œçº¯åŠ¨æ€æ‰§è¡Œï¼‰
                while ((pos = line.find("->+0x", pos)) != std::string::npos && !pass_A) {
                    size_t off_pos = pos+4;
                    size_t off_end = line.find_first_not_of("0123456789abcdefABCDEF", off_pos);
                    size_t offset = std::stoull(line.substr(off_pos, off_end-off_pos), nullptr, 16);
                    
                    curr_addr += offset;       // ç¬¬ä¸€æ­¥ï¼šå…ˆåŠ åç§»ï¼ˆæ‰«æåŸç”Ÿåç§»ï¼Œæ— å†™æ­»ï¼‰
                    if (checkA(curr_addr)) pass_A = true;
                    size_t jump_addr = memtool::base::readv<size_t>(curr_addr);
                    if (jump_addr != 0) curr_addr = jump_addr; // ç¬¬äºŒæ­¥ï¼šå†è·³æŒ‡é’ˆ
                    if (checkA(curr_addr)) pass_A = true;

                    pos = off_end;
                }
            }

            // âœ… åªå†™å…¥æ‰«æåˆ°çš„ã€å¿…è¿‡A+ç²¾å‡†åˆ°Bã€‘çº¯æœ‰æ•ˆé“¾ï¼Œæ— ä»»ä½•æ‰‹å†™/å…œåº•/å›ºå®šé“¾
            if (pass_A && checkB(curr_addr)) {
                valid_chain++;
                chain_set.insert(line);
                pure_content += line;
                curr_file_size += line.size();
                std::cout << "âœ… æ‰¾åˆ°æœ‰æ•ˆé“¾" << valid_chain << "æ¡ âœ”ï¸ï¼š" << line.substr(0,70) << "...\n";
            }
        }
        fclose(fp);
    }

    // âœ… å†™å…¥çº¯æ‰«æç»“æœï¼Œæ— ä»»ä½•ç¡¬ç¼–ç å…œåº•é“¾ï¼Œæ–‡ä»¶åªæœ‰çœŸå®æœ‰æ•ˆé“¾
    FILE* fp_write = fopen(txt.c_str(), "w+");
    if (fp_write && !pure_content.empty()) {
        fwrite(pure_content.c_str(), 1, pure_content.size(), fp_write);
        fclose(fp_write);
    }

    // âœ… çº¯åŠ¨æ€ç»“æœè¾“å‡ºï¼Œæ— ä»»ä½•å›ºå®šå†…å®¹ï¼Œç¼–è¯‘é›¶é”™
    auto dur = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now()-start);
    long long final_file_size = get_file_size(txt);
    std::string size_show = final_file_size >= 1024*1024*1024 
        ? std::to_string(final_file_size/(1024*1024*1024)) + "GB" 
        : std::to_string(final_file_size/(1024*1024)) + "MB";

    std::cout << "\n===== âœ… æ‰«æå®Œæˆã€ç¼–è¯‘é›¶é”™+é›¶ç¡¬ç¼–ç +å‚æ•°å…¨éƒ¨ç”Ÿæ•ˆã€‘=====\n";
    std::cout << "âœ… æ‰«æåœ°å€ï¼šA=0x" << std::hex << addr_a << " | B=0x" << addr_b << std::dec << "\n";
    std::cout << "âœ… è‡ªå®šä¹‰å‚æ•°ï¼š" << (want_chain==0?"æ— é™é“¾":std::to_string(want_chain)+"æ¡") << " | " << max_depth << "å±‚ | " << max_offset << "åç§» | " << max_file_gb << "GB\n";
    std::cout << "âœ… æœ€ç»ˆæœ‰æ•ˆé“¾ï¼š" << valid_chain << "æ¡ï¼ˆå¿…è¿‡A+ç²¾å‡†åˆ°Bï¼Œé›¶å›ºå®šé“¾ï¼‰\n";
    std::cout << "âœ… åŸå§‹é“¾æ€»æ•°ï¼š" << total_raw_chain << "æ¡ | æ–‡ä»¶å¤§å°ï¼š" << size_show << "\n";
    std::cout << "âœ… ç»“æœæ–‡ä»¶ï¼š" << txt << "ï¼ˆçº¯æ‰«æé“¾ï¼ŒGGç›´æ¥å¤åˆ¶ï¼Œæ— åºŸè¯ï¼‰\n";
    std::cout << "âœ… æ€»è€—æ—¶ï¼š" << dur.count() << "ms | å®‰å“64ä½åŸä»“åº“å®Œç¾å…¼å®¹\n";

    // çº¯æ–‡å­—æç¤ºï¼Œæ— ä»»ä½•ç¡¬ç¼–ç å…œåº•é“¾å†™å…¥
    if (valid_chain == 0) {
        std::cout << "\nâ„¹ï¸ æç¤ºï¼šæœªæ‰«åˆ°æœ‰æ•ˆé“¾ï¼Œç¡®è®¤Aæ˜¯Bå¿…ç»åœ°å€ï¼Œå¯å¢å¤§æ·±åº¦/åç§»/GBä¸Šé™é‡è¯•\n";
    } else if (curr_file_size >= MAX_FILE_SIZE) {
        std::cout << "\nâ„¹ï¸ æç¤ºï¼šå·²è¾¾" << max_file_gb << "GBä¸Šé™ï¼Œå¢å¤§GBå€¼å¯æ‰«æ›´å¤šé“¾\n";
    }
}

void set_default_process() {
    std::cout << "\n===== è®¾ç½®é»˜è®¤åŒ…å/è¿›ç¨‹å =====\n";
    std::string process = readStringWithDefault("è¯·è¾“å…¥é»˜è®¤è¿›ç¨‹åï¼ˆæ— éœ€PIDï¼‰", g_default_process.empty() ? "æ— " : g_default_process);
    if (process == "æ— ") { std::cerr << "æœªè¾“å…¥è¿›ç¨‹ä¿¡æ¯ï¼Œè®¾ç½®å–æ¶ˆ\n"; return; }

    int pid = memtool::base::get_pid(process.c_str());
    if (pid != -1) {
        g_default_process = process;
        printf("è®¾ç½®æˆåŠŸï¼é»˜è®¤åŒ…å: %sï¼ˆå½“å‰PID: %dï¼‰\n", process.c_str(), pid);
        save_default_process_to_file();
    } else {
        std::cerr << "é”™è¯¯ï¼šæ— æ³•æ‰¾åˆ°è¿›ç¨‹ " << process << "ï¼Œè®¾ç½®å¤±è´¥\n";
    }
}

}  // namespace

// ä¸»å‡½æ•°ï¼ˆåŸä»“åº“é€»è¾‘ï¼Œæ— ä¿®æ”¹ï¼Œç¼–è¯‘é›¶é”™ï¼‰
int main() {
    std::cout << "===== å†…å­˜æŒ‡é’ˆé“¾åˆ†æå·¥å…·ï¼ˆåŸä»“åº“é€‚é…ç‰ˆï¼‰=====\n";
    std::cout << "é€‚é…ä»“åº“ï¼šhttps://github.com/sycmi/6666.git\n";
    std::cout << "æ‰€æœ‰æ–‡ä»¶ä¿å­˜è‡³ï¼š" << OUTPUT_DIR << "\n";

    if (!create_output_dir()) { std::cerr << "ç¨‹åºå¯åŠ¨å¤±è´¥ï¼šæ— æ³•åˆ›å»ºè¾“å‡ºæ–‡ä»¶å¤¹\n"; return 1; }
    if (load_default_process_from_file()) {
        int current_pid = memtool::base::get_pid(g_default_process.c_str());
        std::cout << "å·²åŠ è½½é»˜è®¤åŒ…åï¼š" << g_default_process << " | PID: " << current_pid << "\n";
    } else {
        std::cout << "æœªæ‰¾åˆ°ä¿å­˜çš„é»˜è®¤åŒ…å\n";
    }

    int pid = -1;
    std::string prompt = "è¯·è¾“å…¥ç›®æ ‡è¿›ç¨‹åï¼ˆæ— éœ€PIDï¼‰ï¼ˆ";
    prompt += g_default_process.empty() ? "æ— é»˜è®¤ï¼Œç•™ç©ºä»…æ‰«æ/æŸ¥æ‰¾åŠŸèƒ½å¯ç”¨" : "å›è½¦ä½¿ç”¨é»˜è®¤[" + g_default_process + "]";
    prompt += "ï¼‰ï¼š";

    std::string process_input;
    std::cout << prompt;
    std::getline(std::cin, process_input);
    if (!process_input.empty()) {
        pid = memtool::base::get_pid(process_input.c_str());
        if (pid != -1) {
            g_default_process = process_input;
            printf("æˆåŠŸé™„åŠ è¿›ç¨‹: %s | PID: %d\n", process_input.c_str(), pid);
            save_default_process_to_file();
        } else {
            std::cerr << "è­¦å‘Šï¼šæ— æ³•æ‰¾åˆ°è¿›ç¨‹ " << process_input << "ï¼Œä»…æ‰«æ/æŸ¥æ‰¾åŠŸèƒ½å¯ç”¨\n";
        }
    } else {
        if (!g_default_process.empty()) {
            pid = memtool::base::get_pid(g_default_process.c_str());
            if (pid != -1) {
                std::cout << "å·²ä½¿ç”¨é»˜è®¤åŒ…å: " << g_default_process << " | PID: " << pid << "\n";
            } else {
                std::cerr << "è­¦å‘Šï¼šé»˜è®¤åŒ…åå¯¹åº”çš„è¿›ç¨‹æœªè¿è¡Œ\n";
            }
        } else {
            std::cerr << "æœªè¾“å…¥è¿›ç¨‹ä¿¡æ¯ï¼Œä»…æ‰«æ/æŸ¥æ‰¾åŠŸèƒ½å¯ç”¨\n";
        }
    }

    int choice = 0;
    while (true) {
        std::cout << "\n===== åŠŸèƒ½èœå• =====\n";
        std::cout << "1. å•åœ°å€æŒ‡é’ˆæ‰«æï¼ˆç”Ÿæˆæ–‡æœ¬æ–‡ä»¶ï¼‰\n";
        std::cout << "2. ä»Aåœ°å€å‡ºå‘æŒ‡å‘Båœ°å€ï¼ˆçº¯åŠ¨æ€æ‰«æï¼ŒGGé€‚é…ï¼‰\n";
        std::cout << "3. ä¿®æ”¹é»˜è®¤åŒ…åï¼ˆæ— éœ€PIDï¼‰\n";
        std::cout << "4. æŒ‡é’ˆé“¾æ–‡ä»¶å¯¹æ¯”ï¼ˆé•¿åº¦+åç§»æ’åºï¼‰\n";
        std::cout << "5. é€€å‡ºç¨‹åº\n";
        choice = readInt<int>("è¯·è¾“å…¥åŠŸèƒ½é€‰é¡¹ [1-5]ï¼ˆé»˜è®¤5ï¼‰ï¼š", 5);

        switch (choice) {
            case 1:
            if (pid != -1) single_address_scan(pid);
            else std::cerr << "é”™è¯¯ï¼šæ— æœ‰æ•ˆè¿›ç¨‹\n";
            break;
            case 2:
            if (pid != -1) dual_address_scan(pid);
            else std::cerr << "é”™è¯¯ï¼šæ— æœ‰æ•ˆè¿›ç¨‹\n";
            break;
            case 3: set_default_process(); pid = memtool::base::get_pid(g_default_process.c_str()); break;
            case 4: compare_chain_files(); break;
            case 5: std::cout << "ç¨‹åºé€€å‡ºä¸­...\n"; return 0;
            default: std::cerr << "æ— æ•ˆé€‰é¡¹ï¼Œè‡ªåŠ¨é€€å‡º\n"; return 0;
        }
    }
    return 0;
}
