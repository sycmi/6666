#pragma once
// 先包含C++标准头文件，解决std命名空间作用域问题（关键）
#include <cstdint>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <unistd.h>
#include <dirent.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/uio.h>
#include <sys/user.h>
#include <sys/types.h>

#include "memsetting.h"

namespace memtool
{
// 提前声明extend子命名空间，解决memextend依赖问题
namespace extend {};

class base
{
private:
    static inline thread_local iovec mem_local[1];
    static inline thread_local iovec mem_remote[1];
    static inline thread_local size_t page_present;
    static inline int page_handle = -1;

protected:
    base(){};
    ~base(){};
    base(const memtool::base &b) = delete;
    base(memtool::base &&b) = delete;
    base &operator=(const memtool::base &b) = delete;
    base &operator=(memtool::base &&b) = delete;

public:
    static inline pid_t target_pid = -1;

    static int get_pid(const char *package);

    template <typename T, typename S>
    static T readv(S addr);

    template <typename S, typename T>
    static long readv(S addr, T *data);

    template <typename S>
    static long readv(S addr, void *data, size_t size);

    static long readv_batch(const std::vector<std::pair<size_t, size_t>> &addr_size_pairs,
                            std::vector<void *> &buffers);

    // ✅ 修复1：正确声明read_pointer模板函数（语法合规）
    template <typename T, typename... Args>
    static T read_pointer(T start, Args &&...offsets);

    // ✅ 地址可访问性校验函数声明
    static bool is_address_accessible(uint64_t addr);
};

} // namespace memtool

// ==================== 类外实现：所有成员函数（语法合规，无嵌套） ====================
inline int memtool::base::get_pid(const char *package)
{
    char command[100];
    snprintf(command, sizeof(command), "pidof %s", package);
    FILE *fp = popen(command, "r");
    if (fp == nullptr) return -1;
    char pid[10];
    fscanf(fp, "%s", pid);
    pclose(fp);
    return atoi(pid);
}

template <typename T, typename S>
inline T memtool::base::readv(S addr)
{
    T temp;
    mem_local->iov_base = &temp;
    mem_local->iov_len = sizeof(T);
    mem_remote->iov_base = reinterpret_cast<void *>(addr);
    mem_remote->iov_len = sizeof(T);
    syscall(SYS_process_vm_readv, target_pid, mem_local, 1, mem_remote, 1, 0);
    return temp;
}

template <typename S, typename T>
inline long memtool::base::readv(S addr, T *data)
{
    mem_local->iov_base = data;
    mem_local->iov_len = sizeof(T);
    mem_remote->iov_base = reinterpret_cast<void *>(addr);
    mem_remote->iov_len = sizeof(T);
    return syscall(SYS_process_vm_readv, target_pid, mem_local, 1, mem_remote, 1, 0);
}

template <class S>
inline long memtool::base::readv(S addr, void *data, size_t size)
{
    mem_local->iov_base = data;
    mem_local->iov_len = size;
    mem_remote->iov_base = reinterpret_cast<void *>(addr);
    mem_remote->iov_len = size;
    if(size>1024*1024)
    printf("readv size=  %zu MB\n",size/1024/1024);

    long result= syscall(SYS_process_vm_readv, target_pid, mem_local, 1, mem_remote, 1, 0);
    return result;
}

inline long memtool::base::readv_batch(const std::vector<std::pair<size_t, size_t>> &addr_size_pairs,
            std::vector<void *> &buffers) {
  constexpr size_t MAX_IOV = 256;
  std::vector<iovec> local(std::min(addr_size_pairs.size(), MAX_IOV));
  std::vector<iovec> remote(std::min(addr_size_pairs.size(), MAX_IOV));

  for (size_t i = 0; i < std::min(addr_size_pairs.size(), MAX_IOV); ++i) {
    local[i].iov_base = buffers[i];
    local[i].iov_len = addr_size_pairs[i].second;
    remote[i].iov_base = reinterpret_cast<void *>(addr_size_pairs[i].first);
    remote[i].iov_len = addr_size_pairs[i].second;
  }

  return syscall(SYS_process_vm_readv, target_pid, local.data(), local.size(),
                 remote.data(), remote.size(), 0);
}

// ✅ 修复2：彻底修正read_pointer模板函数（语法+逻辑双正确，解决核心报错）
template <typename T, typename... Args>
inline T memtool::base::read_pointer(T start, Args &&...offsets)
{
    T current_addr = start;
    // 正确展开可变参数偏移列表
    std::vector<T> offset_list = {static_cast<T>(offsets)...};
    // 指针链遍历：基地址+偏移 → 读指针 → 再加偏移
    for (size_t i = 0; i < offset_list.size(); ++i)
    {
        current_addr += offset_list[i]; // 加偏移
        if (i < offset_list.size() - 1) // 最后一步不加偏移，直接返回
        {
            current_addr = memtool::base::readv<T>(current_addr); // 读指针地址
        }
    }
    return current_addr;
}

// ✅ 地址可访问性校验函数实现（复用process_vm_readv，无语法错）
inline bool memtool::base::is_address_accessible(uint64_t addr)
{
    char test_buf[1] = {0};
    mem_local->iov_base = test_buf;
    mem_local->iov_len = 1;
    mem_remote->iov_base = reinterpret_cast<void*>(addr);
    mem_remote->iov_len = 1;
    long ret = syscall(SYS_process_vm_readv, target_pid, mem_local, 1, mem_remote, 1, 0);
    return ret > 0;
}
